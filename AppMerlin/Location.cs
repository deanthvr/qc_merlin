using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Serialization;

namespace AppMerlin
{
  public abstract class Location
  {
    //                                  my in or out                    neighbor     their corresponding in or out
    [XmlIgnore]
    public List<MerlinKeyValuePair<BalancingInsOuts, MerlinKeyValuePair<Location, BalancingInsOuts>>> m_Neighbors;
    public MerlinKeyValuePair<int, int> m_BalancingLocation;
    [XmlIgnore]
    public TMCProject m_ParentProject;
    /// <summary>
    /// Location ID which comes from QC website if imported, otherwise generated by Merlin.
    /// </summary>
    public int Id;
    public string Latitude;
    public string Longitude;
    public List<Note> m_Notes;
    protected int[] xmlNeighbors;
    /// <summary>
    /// Neighbor connections as an array which is used for serialization.
    /// </summary>
    public int[] m_XmlNeighbors
    {
      get
      {
        return GetNeighborsAsArrayForXml();
      }
      set
      {
        xmlNeighbors = value;
        //SetNeighborsFromXml();
      }
    }

    #region Constructors

    public Location() : this(new TMCProject(), -1, "", "") {}

    public Location(TMCProject parentProject, int ID, string lat, string lon)
    {
      m_Neighbors = new List<MerlinKeyValuePair<BalancingInsOuts, MerlinKeyValuePair<Location, BalancingInsOuts>>>();
      m_XmlNeighbors = new int[0];
      m_BalancingLocation = new MerlinKeyValuePair<int, int>(-1, -1);
      m_ParentProject = parentProject;
      Id = ID;
      Latitude = lat;
      Longitude = lon;
      m_Notes = new List<Note>();

    }

    #endregion

    #region Abstract Methods

    public abstract PossibleConnectionFlows GetTrafficFlowTypeAtConnection(BalancingInsOuts myConnection);

    public abstract string GetLocationName();

    public abstract string GetLocationNumber();

    #endregion

    #region Static Methods

    public static bool IsConnectionEntering(BalancingInsOuts connection)
    {
      //Kind of a hacky way to see if this connection is entering or exiting by comparing the string value
      return connection.ToString().Substring(3, 1) == "n";
    }

    #endregion

    #region Private Helper Methods

    private int[] GetNeighborsAsArrayForXml()
    {
      int[] neighborsAsArray = new int[m_Neighbors.Count * 3];
      for (int i = 0; i < m_Neighbors.Count; i++)
      {
        neighborsAsArray[i * 3 + 0] = (int)m_Neighbors[i].Key;  //my connection
        neighborsAsArray[i * 3 + 1] = m_Neighbors[i].Value.Key.Id;  //ID of neighbor location
        neighborsAsArray[i * 3 + 2] = (int)m_Neighbors[i].Value.Value;  //connection at neighbor
      }
      return neighborsAsArray;
    }    

    public void SetNeighborsFromXml()
    {
      m_Neighbors.Clear();
      for (int i = 0; i < xmlNeighbors.Length / 3; i++)
      {
        m_Neighbors.Add(new MerlinKeyValuePair<BalancingInsOuts, MerlinKeyValuePair<Location, BalancingInsOuts>>((BalancingInsOuts)xmlNeighbors[i * 3 + 0], new MerlinKeyValuePair<Location, BalancingInsOuts>(m_ParentProject.GetLocation(xmlNeighbors[i * 3 + 1]), (BalancingInsOuts)xmlNeighbors[i * 3 + 2])));
      }
    }

    #endregion

    #region Public Neighbor Methods

    /// <summary>
    /// Determines whether a connection is possible based on the geometries of the current location and the potential neighbor location
    /// </summary>
    /// <param name="myConnection">In or out at the current location</param>
    /// <param name="neighbor">Location that is to be the neighbor</param>
    /// <param name="theirConnection">In or out at the neighbor location</param>
    /// <returns>Whether or not this connection is possible</returns>
    public bool IsConnectionPossible(BalancingInsOuts myConnection, Location neighbor, BalancingInsOuts theirConnection)
    {
      PossibleConnectionFlows myTrafficFlow = this.GetTrafficFlowTypeAtConnection(myConnection);
      PossibleConnectionFlows theirTrafficFlow = neighbor.GetTrafficFlowTypeAtConnection(theirConnection);

      return  (myTrafficFlow == PossibleConnectionFlows.In && theirTrafficFlow == PossibleConnectionFlows.Out) || 
              (myTrafficFlow == PossibleConnectionFlows.Out && theirTrafficFlow == PossibleConnectionFlows.In);
    }

    
    /// <summary>
    /// Returns the neighbor connected to the given in/out connection
    /// </summary>
    /// <param name="myConnection">Specifies the in or out at this location to look for connected neighbor</param>
    /// <returns>KeyValuePair of the connected location and the connection at that location, this pair will contain uninitialized bogus objects if neighbor doesn't exist.</returns>
    public MerlinKeyValuePair<Location, BalancingInsOuts> GetNeighbor(BalancingInsOuts myConnection)
    {
      foreach (MerlinKeyValuePair<BalancingInsOuts, MerlinKeyValuePair<Location, BalancingInsOuts>> connection in m_Neighbors)
      {
        if (connection.Key == myConnection)
        {
          return connection.Value;
        }
      }
      return new MerlinKeyValuePair<Location, BalancingInsOuts>();
    }

    /// <summary>
    /// Generates and returns a new neighbor connection.
    /// </summary>
    /// <param name="myConnection">In or out at the current location</param>
    /// <param name="loc">Location that is to be the neighbor</param>
    /// <param name="theirConnection">In or out at the neighbor location</param>
    /// <returns></returns>
    public static MerlinKeyValuePair<BalancingInsOuts, MerlinKeyValuePair<Location, BalancingInsOuts>> GenerateNewNeighborConnection(BalancingInsOuts myConnection, Location loc, BalancingInsOuts theirConnection)
    {
      MerlinKeyValuePair<Location, BalancingInsOuts> newNeighbor = new MerlinKeyValuePair<Location, BalancingInsOuts>(loc, theirConnection);
      MerlinKeyValuePair<BalancingInsOuts, MerlinKeyValuePair<Location, BalancingInsOuts>> newConnectionToNeighbor = new MerlinKeyValuePair<BalancingInsOuts, MerlinKeyValuePair<Location, BalancingInsOuts>>(myConnection, newNeighbor);

      return newConnectionToNeighbor;
    }

    /// <summary>
    /// Sets a neighbor for the given connection at current location and connection at neighbor.
    /// </summary>
    /// <param name="myConnection">Connection at this intersection</param>
    /// <param name="neighbor">Location that is a neighbor of this location</param>
    /// <param name="theirConnection">Connection at neighbor</param>
    public void SetNeighbor(BalancingInsOuts myConnection, Location neighbor, BalancingInsOuts theirConnection)
    {
      //If attempting to set a neighbor connection that already exists, delete existing first
      if (GetNeighbor(myConnection).Key != null)
      {
        MerlinKeyValuePair<BalancingInsOuts, MerlinKeyValuePair<Location, BalancingInsOuts>> connectionToReplace = new MerlinKeyValuePair<BalancingInsOuts, MerlinKeyValuePair<Location, BalancingInsOuts>>();
        foreach (MerlinKeyValuePair<BalancingInsOuts, MerlinKeyValuePair<Location, BalancingInsOuts>> connection in m_Neighbors)
        {
          if (connection.Key == myConnection)
          {
            connectionToReplace = connection;
            break;
          }
        }
        m_Neighbors.Remove(connectionToReplace);

      }
      //Add neighbor connection if possible (there isn't a one way or ped only preventing the connection)
      if (IsConnectionPossible(myConnection, neighbor, theirConnection))
      {
        m_Neighbors.Add(GenerateNewNeighborConnection(myConnection, neighbor, theirConnection));
      }
    }

    /// <summary>
    /// Sets a neighbor for the given connection at current intersection. Connection at neighbor is assumed to be the same direction as current intersection connection.
    /// </summary>
    /// <param name="myConnection"></param>
    /// <param name="neighbor"></param>
    public void SetNeighbor(BalancingInsOuts myConnection, Location neighbor)
    {
      //Assumes the connection at neighbor based on the connection at this intersection
      BalancingInsOuts connectionAtNeighbor = (BalancingInsOuts)(((int)myConnection + 4) % 8);
      SetNeighbor(myConnection, neighbor, connectionAtNeighbor);
    }

    /// <summary>
    /// Removes the neighbor for the given connection at current location and connection at neighbor.
    /// </summary>
    public void RemoveNeighborConnection(BalancingInsOuts myConnection)
    {
      if (m_Neighbors.Exists(x => x.Key == myConnection))
      {
        MerlinKeyValuePair<BalancingInsOuts, MerlinKeyValuePair<Location, BalancingInsOuts>> myDeletion = m_Neighbors.Find(x => x.Key == myConnection);
        MerlinKeyValuePair<BalancingInsOuts, MerlinKeyValuePair<Location, BalancingInsOuts>> theirDeletion = myDeletion.Value.Key.m_Neighbors.Find(x => x.Key == myDeletion.Value.Value);
        myDeletion.Value.Key.m_Neighbors.Remove(theirDeletion);
        m_Neighbors.Remove(myDeletion);

      }
    }

    /// <summary>
    /// Removes all neighbors for the  current location and connections at those neighbors.
    /// </summary>
    public void RemoveAllNeighbors()
    {
      for (int i = m_Neighbors.Count - 1; i >= 0; i--)
      {
        RemoveNeighborConnection(m_Neighbors[i].Key);
      }
    }

    #endregion

  }
}
